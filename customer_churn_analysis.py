# -*- coding: utf-8 -*-
"""Customer Churn Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1II5f-v_fts68xNfE_A9EqOLTyOgTLSPm
"""

# customer_churn_analysis.py
# End-to-End Customer Churn Analysis (No ML)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# -----------------------------
# STEP 1: DATA GENERATION
# -----------------------------
np.random.seed(42)

rows = 7000

df = pd.DataFrame({
    "Customer_ID": np.arange(50001, 50001 + rows),
    "Tenure_Months": np.random.randint(1, 60, rows),
    "Monthly_Charges": np.round(np.random.uniform(300, 3000, rows), 2),
    "Total_Usage_GB": np.round(np.random.uniform(5, 500, rows), 2),
    "Subscription_Type": np.random.choice(
        ["Basic", "Standard", "Premium"], rows, p=[0.4, 0.35, 0.25]
    ),
    "Payment_Method": np.random.choice(
        ["Credit Card", "Debit Card", "UPI", "Net Banking"], rows
    ),
    "Customer_Support_Calls": np.random.randint(0, 12, rows),
    "Churn": np.random.choice(["Yes", "No"], rows, p=[0.27, 0.73])
})
# Add missing values
df.loc[df.sample(frac=0.02).index, "Payment_Method"] = None

print("Raw data shape:", df.shape)

# -----------------------------
# STEP 2: DATA CLEANING
# -----------------------------
df["Payment_Method"].fillna("Unknown", inplace=True)

print("Missing values after cleaning:")
print(df.isnull().sum())

# -----------------------------
# STEP 3: KPI METRICS
# -----------------------------
total_customers = df.shape[0]
churned_customers = df[df["Churn"] == "Yes"].shape[0]
churn_rate = round((churned_customers / total_customers) * 100, 2)

print("\n--- KPI SUMMARY ---")
print("Total Customers:", total_customers)
print("Churned Customers:", churned_customers)
print("Churn Rate (%):", churn_rate)

# -----------------------------
# STEP 4: CHURN BY SUBSCRIPTION TYPE
# -----------------------------
churn_by_plan = df.groupby(["Subscription_Type", "Churn"]).size().unstack()

plt.figure()
churn_by_plan.plot(kind="bar", stacked=True)
plt.title("Churn by Subscription Type")
plt.ylabel("Number of Customers")
plt.xlabel("Subscription Type")
plt.tight_layout()
plt.show()

# STEP 5: TENURE VS CHURN
# -----------------------------
plt.figure()
sns.boxplot(x="Churn", y="Tenure_Months", data=df)
plt.title("Customer Tenure vs Churn")
plt.tight_layout()
plt.show()

# -----------------------------
# STEP 6: USAGE PATTERN ANALYSIS
# -----------------------------
usage_churn = df.groupby("Churn")["Total_Usage_GB"].mean()

plt.figure()
usage_churn.plot(kind="bar")
plt.title("Average Usage by Churn Status")
plt.ylabel("Usage (GB)")
plt.tight_layout()
plt.show()

# -----------------------------
# STEP 7: CUSTOMER SUPPORT IMPACT
# -----------------------------
support_churn = df.groupby("Churn")["Customer_Support_Calls"].mean()
plt.figure()
support_churn.plot(kind="bar")
plt.title("Support Calls vs Churn")
plt.ylabel("Average Support Calls")
plt.tight_layout()
plt.show()

# -----------------------------
# STEP 8: MONTHLY CHARGES VS CHURN
# -----------------------------
plt.figure()
sns.boxplot(x="Churn", y="Monthly_Charges", data=df)
plt.title("Monthly Charges vs Churn")
plt.tight_layout()
plt.show()

# -----------------------------
# STEP 9: BUSINESS INSIGHTS
# -----------------------------
print("\n--- BUSINESS INSIGHTS ---")
print("1. Customers with lower tenure are more likely to churn.")
print("2. Higher customer support calls correlate with higher churn.")
print("3. Basic plan users show higher churn than premium users.")
print("4. Low usage customers churn more frequently.")
print("5. Pricing sensitivity affects churn behavior.")

# -----------------------------
# STEP 10: SAVE CLEAN DATA
# -----------------------------
df.to_csv("cleaned_customer_churn_data.csv", index=False)
print("\nCleaned dataset saved as cleaned_customer_churn_data.csv")

